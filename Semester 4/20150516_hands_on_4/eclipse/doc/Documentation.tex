
\documentclass[11pt, a4paper, twoside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format

\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\usepackage{pdfpages}
\usepackage{caption}
\usepackage{minted}
\usepackage[german]{babel}			% this end the next are needed for german umlaute
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{hyperref}
% http://www.artofproblemsolving.com/wiki/index.php/LaTeX:Symbols#Operators
% =============================================
% Layout & Colors
% =============================================
\geometry{
   a4paper,
   total={210mm,297mm},
   left=20mm,
   right=20mm,
   top=20mm,
   bottom=30mm
 }	

\definecolor{myred}{rgb}{0.8,0,0}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\setcounter{secnumdepth}{4}


% the default java directory structure and the main packages
\newcommand{\srcDir}{../src/main/java}
\newcommand{\srcTestDir}{../src/test/java}
\newcommand{\mainPackageDir}{\srcDir/at/fh/ooe/swe4/puzzle}
\newcommand{\mainTestPackageDir}{\srcTestDir/at/fh/ooe/swe/test/}
\newcommand{\mainTestPackage}{at.fh.ooe.swe.test}
\newcommand{\imagesDir}{images}
% the default subsection headers
\newcommand{\ideaSection}{Lösungsidee}
\newcommand{\sourceSection}{Source-Code}
\newcommand{\testSection}{Tests}

% =============================================
% Code Settings
% =============================================
\newenvironment{code}{\captionsetup{type=listing}}{}
\newmintedfile[javaSourceFile]{java}{
	linenos=true, 
	frame=single, 
	breaklines=true, 
	tabsize=2,
	numbersep=5pt,
	xleftmargin=10pt,
	baselinestretch=1,
	fontsize=\footnotesize
}
\newmintinline[inlineJavaSource]{java}{}
\newminted[javaSource]{java}{
	breaklines=true, 
	tabsize=2,
	autogobble=true,
	breakautoindent=false
}
% =============================================
% Page Style, Footers & Headers, Title
% =============================================
\title{Übung 3}
\author{Thomas Herzog}

\lhead{Übung 3}
\chead{}
\rhead{\includegraphics[scale=0.10]{FHO_Logo_Students.jpg}}

\lfoot{S1310307011}
\cfoot{}
\rfoot{ \thepage / \pageref{LastPage} }
\renewcommand{\footrulewidth}{0.4pt}
% =============================================
% D O C U M E N T     C O N T E N T
% =============================================
\pagestyle{fancy}
\begin{document}
\setlength{\headheight}{15mm}

{\color{myred}
	\section
		{Verschiebe Puzzle A*-Algorithmus}
}

\subsection{\ideaSection}
Folgend ist die Dokumentation für die Aufgabenstellung Verschiebe Puzzle mit A*-Algorithmus angeführt. \\
Es werden zwar Klassenspezifikationen angegeben, jedoch soll nicht stur diesen gefolgt werden, obwohl die Semantik beibehalten werden soll.\\
Bezüglich der konkreten Spezifikation der APIs und Implementierungen sei auf den Bereich \emph{Source} verwiesen, wo einerseits beschrieben wird warum die API oder Implementierung so gewählt wurde und andererseits ist im angeführten Source die Javadoc enthalten. Ich finde es besser den Source über Javadoc zu kommentieren als in einem externen Dokument.

\subsubsection{Maven Projekt}
Dieses Mal soll das Projekt als Maven Projekt implementiert werden, da es sich hierbei um ein bekanntes und meist genutztes Framwork für Build Konfiguration handelt und es sehr einfach erlaubt Dependencies einzubinden und auch automatisch die Sources zur Verfügung stellt.\\
Dies sollte kein Problem darstellen, da Eclipse LUNA bereits mit Maven ausgelifert wird. Es soll gewährleistet werden, dass es keine speziellen Konfigurationen erfordert um das Projekt, in der von der FH zur Verfügung gestellten VM, zu importieren und zum Laufen zu bringen.\\
Jedoch sei angemerkt das es ein \emph{Update Projekt} von Nöten sein wird um alle Dependencies von den Maven Repositories zu bekommen. Des Weiteren sollen keine Änderungen an der Standard \emph{settings.xml} vorgenommen werden.\\\\
Für weitere Informationen bezüglich der Maven Konfiguration sei auf den Bereich \emph{Sources} verwiesen, in dem die \emph{pom.xml} angeführt ist. Dort ist auch beschrieben mit welchen Maven Build command das Projekt gebuildet werden soll, da es auch Konfigurationen geben soll, die einen report für die Tests erstellen. 

\subsubsection{JUnit Tests}
Wie verlangt soll testgetrieben vorgegangen werden wobei anstatt einer riesigen Testklasse pro getesteter Methode eine eigene Test-Klasse implementiert werden, da es pro Testmethode sicherlich mehr als eine Test-Methode geben wird. \\
Bei den JUnit Tests soll sich an folgende Konvention gehalten werden: \\
\begin{enumerate}
	\item \textbf{Test-Root-Package:} Alle Test-Klassen sollen im package \emph{\mainTestPackage.*} zusammengefasst werden. \\
	Dadurch liegen alle Test-Klassen in einer eignen Domain und sind völlig unabhängig vom eigentlichen Source
	\item \textbf{Test-API-Package:} Alle Test-Resourcen wie z.B.: abstrakte Test-Klassen sollen im Package \emph{\mainTestPackage.api.*} liegen. \\
	Dadurch ist erkennbar das es sich hierbei um eine API für die Tests handelt.
	\item \textbf{Test-Packages:} Alle tatsächlichen Tests sollen in Packages liegen die wie folgt aufgebaut sein sollen '\emph{\mainTestPackage.\textless sourcePackage\textgreater .\textless testedClassName\textgreater (\mainTestPackage.puzzle.impl.boardImpl.*)}', wobei man sich an die Java Bean Convention zu halten hat.
	\item \textbf{Test-Klassen:} Die Test-Klassen Name sollen wie folgt aufgebaut sein: '\emph{\textless testedMethodName\textgreater Test (SolveTest, MakeMoveTest, usw.)}' \\
	Ein Spezialfall währen die Konstruktor Tests, die folgende Konvention folgen sollen. \emph{\textless meaning\textgreater ConstructorTest (DefaultConstructorTest, CopyConstructorTest, usw.)}
	\item \textbf{Test-Methoden:} Die Test-Methoden sollen so benannt werden, dass man leicht erkennen kann was getestet wird. Ein Präfix mit \emph{test} ist zu vermeiden, da ja klar ist das es sich bei Methoden in Testklassen um Tests handelt. \emph{(nullIterable, validAllFieldsRowPerRowLeftToRight, usw.)}
\end{enumerate}
Für die JUnit Test soll JUnit4 verwendet werden wobei hierbei so viele Features wie möglich genutzt werden sollen. Da sicherlich bei den nächsten Übungen auch JUnit Test implementiert werden müssen, sollen alle Ressourcen, die bei anderen Tests wiederverwendet werden sollen in ein eigenes Projekt ausgelagert werden \emph{junit-test-suite}, sodass diese Ressourcen einfach in anderen Projekten verwendet werden können. Es ist darauf zu achten, dass es absolut keine Abhängigkeiten zu dem eigentlichen Projekt gibt und das die Implementierungen so aufgebaut sind, dass sie für jedes anderes Projekt ohne Modifikation wiederverwendet werden können. \\\\
Da wir dazu gezwungen sind in dieser Dokumentation auch die Testresultate anzuführen und die Screenshots etwas zu wenig erscheinen, soll ein Logging implementiert werden, dass die Testresultate auf der Konsole ausgibt. Hierbei sollen \emph{TestWatcher} implementiert werden, die einerseits die Invocation einer Testklasse sowie einer Testmethode auf die Konsole loggen. Hierbei soll ein bekanntes Logging Framework namens Log4j verwendet werden.
\newpage

\subsection{\sourceSection}
Folgend sind die Sources dieser Übung angeführt, sowie die Maven Konfiguration diese Projekts.\\
Pro Source wird auch beschrieben warum die API oder Implementierung so gewählt wurde.\\\\
Für weitere Informationen bezüglich der Implementierungen sei auf die Javadoc verwiesen.

\subsubsection{BoardListImpl.java}
Folgend ist das Interface \emph{Board.java} angeführt, welches die Spezifikation für die Board Implementierung darstellt. Es wurde beschlossen ein eigenes Interface zu spezifizieren, da es auch möglich sein soll den Container für die Verwaltung der Kacheln auszutauschen (\inlineJavaSource{List<T>, T[], usw.})\\
Des weiteren wurde beschlossen eine Typdefinition zu verlangen, da es auch möglich sein soll andere Datentypen außer Integer für die Kacheln zu verwenden, den die einzige Voraussetzung ist, dass sich der Datentyp einer Rangordnung unterwerfen lässt, was über das Interface \inlineJavaSource{Comparable<T>} gewährleistet wird. Es spielt hierbei keine Rolle um welchen Datentyp es sich handelt \inlineJavaSource{Integer, BigInteger, Decimal, Character, usw.}, das einzig wichtige ist das der Datentyp das Interface \inlineJavaSource{Comparable<T>} korrekt implementiert.    
\begin{code}
	\caption{BoardListImpl.java}
	\javaSourceFile{\mainPackageDir/api/Board.java}
\end{code}
\newpage

\subsubsection{BoardImpl.java}
Folgend ist die Implementierung für das Interface \inlineJavaSource{Board.java} angeführt, welches als Container eine \inlineJavaSource{ArrayList} verwendet. Dieser Container wurde gewählt da es sich im Hintergrund um ein \inlineJavaSource{Array} handelt, daher indexierte Zugriffe möglich sind, dieser Container jedoch Methoden zur Verfügung stellt die den Zugriff bzw. die Handhabung dieses \inlineJavaSource{Array} erleichtert.\\
Der Container wird mit der zu erwartenden Größe initialisiert um ein dynamisches wachsen, welches ein \inlineJavaSource{Array.copy(...)} verursacht, zu vermeiden.\\
Dies ist zwar nicht zwingend notwendig aber ist als Best Practise anzusehen.
\begin{code}
	\caption{Board.java}
	\javaSourceFile{\mainPackageDir/impl/BoardListImpl.java}
\end{code}
\newpage

\subsubsection{SlidingPuzzle.java}
Folgend ist die Implementierung des SlidingPuzzle angeführt, welches die Boards versucht in die Zielkonfiguration zu überführen. Da es möglich sein soll nicht ur eine Zielkonfiguration zu handeln wurde die Implementierung erweitert um die Möglichkeit eine Zielkonfiguration zu übergeben.\\
Diese Klasse wurde nach dem Pattern \emph{Fluent Interface} implementiert, da es dieser Pattern erlaubt hier eine gut verständliche Aufrufkette aufzubauen. Diese Aufrufkette liest sich wie Prosa wie in diesem Beispiel ersichtlich. 
\begin{javaSource}
	// Create new slide instance
	SlidingPuzzle<Integer> slider = new SlidingPuzzle<>(); 
	// start the slider with the initial board
	slider.start(initialBoard)
		// Try to solve the board (returns SolutionHandler instance)
		.solve(goalBoard)      
		// Starts the SolutionHandler instance
		.start()      
		// Regsiter custom logger with custom level
		.registerLogger(myLog, Level.DEBUG)   
		// Fill resulting moves in given list      
		.fillMoves(moves)
		// prints the resulting moves via the logger
		.printMoves()
		// performs the moves on the inital board and logs inital/resulting board state
		.performMoves()
		// ends the SolutionHandler, returns related SlidingPuzzle instance
		.end()
		// Ends the SlidingPuzzle instance (reset state)
		.end();
\end{javaSource} 
Es wurde eine interne Klasse \inlineJavaSource{SolutionHandler} implementiert, welche das Handling der Lösung übernimmt. Auch diese Implementierung verwendet \emph{Fluent Interface}. \\
Um durchgehend mit demselben Typ zu arbeiten wird auch hier die Typdefinition verlangt, die der Typdefinition der Kacheln im \inlineJavaSource{Board} entspricht. Damit ist gewährleistet, dass z.B.: eine \inlineJavaSource{SlidingPuzzle<Integer>} Instanz nur auf \inlineJavaSource{Board<Integer>} Instanzen angewendet werden kann und nicht z.B.: auf \inlineJavaSource{Board<Character>} Instanzen.\\\\
Das macht es unmöglich einen Knoten mit einen bestimmten gesetzten Board zu erhalten, daher kann es auch keine Optimierung des Algorithmus geben, wobei bereits besuchte Knoten mit geringeren Kosten ausgenommen werden können.\\
Des Weiteren ist schwer aus einem \inlineJavaSource{Set<T>} einen Knoten rauszubekommen. Man müsste über den gesamten Container iterieren und den Knoten suchen. Dieses Problem haben wir auch bei einer \inlineJavaSource{PriorityQueue<T>}.\\\\
Daher wurden folgende Container gewählt:\
\begin{enumerate}
	\item \textbf{\inlineJavaSource{PriorityQueue<T>}:} DIe Queue, die die Knoten mit den geringsten Kosten vorne anreiht und diese zuerst zurückliefert.
	\item \textbf{\inlineJavaSource{HashMap<Board<T>, SearchNode<T>>}: } Für die bereits untersuchten und offenen Knoten. Hierbei haben wir konstante Laufzeit beim Hinzufügen und Erhalten eines Knoten aus der Map, da hier über die Hash-Funktion \inlineJavaSource{board.hashCode()} die Knoten in der Map adressiert werden. (Beinahe konstante Laufzeit aufgrund von Kollisionen) 
\end{enumerate}
Der Algorithmus versucht die Nachfolgeknoten des aktuell untersuchten Knoten in den Container offene wie auch geschlossenen Knoten zu finden und zu entscheiden ob diese Knoten der Container geringere Kosten besitzen. Wenn ja werden die aktuellen Nachfolgeknoten ignoriert und nicht weiter untersucht, da es schon einen besseren Weg zu diesem Board Status gibt.
\begin{code}
	\caption{BoardListImpl.java}
	\javaSourceFile{\mainPackageDir/impl/SlidingPuzzle.java}
\end{code}
\newpage

\subsubsection{Position.java}
Folgend ist der Source des Models \inlineJavaSource{Position} angeführt, welches dafür verwendet wird um die Position der leeren Kacheln zu liefern, da es mir zu wenig erschien nur mit der Spalte der leeren Kacheln zu arbeiten.
\begin{code}
	\caption{Position.java}
	\javaSourceFile{\mainPackageDir/model/Position.java}
\end{code}
\newpage

\subsubsection{SearchNode.java}
Folgend ist der Source des Models \inlineJavaSource{SearchNode<T>} angeführt, welches den Knoten für den A*-Algorithmus darstellt. Hierbei sei die Implementierung der Methoden \inlineJavaSource{node.hashCode(); node.equals(other)} erwähnt, die nicht nur das referenzierte \inlineJavaSource{Board<T>} verwendet sondern auch die Gesamtkosten.\\
Das Problem mit diesen Implementierungen ist, dass bei der Verwendung eines \inlineJavaSource{Set<T>} Containers, welcher die geschlossenen Knoten enthält, Duplikate enthalten würde. Also Knoten mit demselben \inlineJavaSource{Board} aber mit unterschiedlichen gesetzten Kosten.\\
Daher dürfen diese Knoten nicht in Containern verwendet werden, die deren \inlineJavaSource{node.hashCode(); node.equals(Object other)} verwenden.
\subsection{\testSection}
% =============================================
% 2. Sorting algorithms
% =============================================
% Idea (common)
% =============================================
\newpage
{\color{myred}
	\section
		{Sortieralgorithmen}
}
\subsection{\ideaSection \hspace{2mm}(Allgemein)}
\newpage
\subsubsection{Source Code\hspace{2mm}(Allgemein)}

\newpage
% =============================================
% 2.1 Statistics
% =============================================
% Idea (stastistics)
% =============================================
\subsection{\ideaSection \hspace{2mm}(Statistics)}

\newpage
\subsubsection{Source Code}

\newpage
\subsection{HeapSorter}
\newpage
\subsubsection{Source Code}
\newpage
\subsubsection{\testSection}
\newpage
\subsection{QuickSorter}

\newpage
\subsubsection{Source Code}

\newpage
\subsubsection{\testSection}
% =============================================
% 2.2 Zeitausertung
% =============================================
\newpage
{\color{myred}
	\section
		{Zeitauswertung}
}
\end{document}  