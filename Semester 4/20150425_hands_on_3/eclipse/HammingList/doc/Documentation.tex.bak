%!TEX encoding = UTF-8 Unicode
\documentclass[11pt, a4paper, twoside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format

\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\usepackage{listings}				% For Source Code displaying
\usepackage[german]{babel}			% this end the next are needed for german umlaute
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{hyperref}
% http://www.artofproblemsolving.com/wiki/index.php/LaTeX:Symbols#Operators
% =============================================
% Layout & Colors
% =============================================
\geometry{
   a4paper,
   total={210mm,297mm},
   left=20mm,
   right=20mm,
   top=20mm,
   bottom=30mm
 }	

\definecolor{myred}{rgb}{0.8,0,0}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

% the default java directory structure and the main packages
\newcommand{\srcDir}{../src/main/java}
\newcommand{\srcTestDir}{../src/test/java}
\newcommand{\mainPackage}{\srcDir/at/fhooe/swe4/lab3}
\newcommand{\mainTestPackage}{\srcTestDir/at/fhooe/swe4/lab3/test}
\newcommand{\junitReportDir}{junit-report}
% the default subsection headers
\newcommand{\ideaSection}{Lösungsidee}
\newcommand{\sourceSection}{Source-Code}
\newcommand{\testSection}{Tests}


% =============================================
% Code Settings
% =============================================
\lstset{ %
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=t,                    % sets the caption-position to top
  commentstyle=\color{mygreen},    % comment style
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=JAVA, 
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{white},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

% =============================================
% Page Style, Footers & Headers, Title
% =============================================
\title{Übung 3}
\author{Thomas Herzog}

\lhead{Übung 3}
\chead{}
\rhead{\includegraphics[scale=0.10]{FHO_Logo_Students.jpg}}

\lfoot{S1310307011}
\cfoot{}
\rfoot{ \thepage / \pageref{LastPage} }
\renewcommand{\footrulewidth}{0.4pt}
% =============================================
% D O C U M E N T     C O N T E N T
% =============================================
\pagestyle{fancy}
\begin{document}
\setlength{\headheight}{15mm}
% =============================================
% Solution Idea
% =============================================
{\color{myred}
	\section
		{Hammingfolge}
}

\subsection{\ideaSection}
Folgend ist die Lösungsidee für die Aufgabenstellung Hammingfolge berechnen angeführt.\\
Da es sich hierbei lediglich um einen einzigen Algorithmus handelt soll dieser als Klassenmethode implementiert werden. Das diese Klasse lediglich diese Klasenmethode enthalten soll, soll in dieser Klasse ein Privater Konstruktor implementiert werden um zu verhindern, dass diese Klasse instanziert werden kann.\\\\
Da eine Hammingfolge wie folgt definiert ist:\\
$1 \in H$ \\
$x \in H \Rightarrow 2 \ast x \in H \wedge 3 \ast x \in H \wedge 5 \ast x \in H$\\
wissen wir dass folgende Elemente Aufgrund dessen das $1 \in H$ gilt in der Folge vorhanden sind. \\
$1 \in H \wedge 2 \in H \wedge 3 \in H \wedge 5 \in H$\\
daher können wir einen Algorithmus definieren der sich wie folgt verhalten soll:
\begin{enumerate}
	\item Erstelle eine Liste und initialisiere diese Liste mit dem Element 1
		\item Berechne die nachfolgenden Hammingzahlen $(2 \ast list.get(i) \wedge 3 \ast list.get(i) \wedge 5 \ast list.get(i))$ für das Element am Index i
		\begin{itemize}
			\item Ist die Zahl vorhanden: Dann füge sie nicht der Liste hinzu
			\item Ist die Zahl nicht vorhanden: Dann füge sie der Liste hinzu
		\end{itemize}
		\item Wiederhole Schritt 2 solange folgendes gilt: $list.size(i) < (n + 4)$
\end{enumerate}
Nun stellt sich die Frage warum folgende Schleifenbedingung gilt $list.size(i) < (n + 4)$\\
Dies ist erforderlich da ansonsten nicht die Folge von Hammingzahlen bis zur Schranke n (=Anzahl) berechnet würde. Es würden zwar gültige Hammingzahlen in der Liste vorhanden sein, jedoch würden bei einer berechneten Hammingfolge die letzten berechneten Zahlen nicht die letzten Hammingzahlen der berechneten Folge sein.\\\\
\underline{Im folgenden Beispiel wird Problematik genau erläutert:}\\
Sei $n=10$ daraus folgt $H_{10} = \{1, 2, 3, 4, 5, 6, 8, 9, 10, 12\}$\\
Mit dem oben beschriebenen Algorithmus würde nun folgende passieren, wobei die Aufzählungen dem Index $i = (x - 1)$ entsprechen 
\begin{enumerate}
	\item $1 \ast 2 = 2 \wedge 1 \ast 3 = 3 \wedge 1 \ast 5 = 5$\\
	$H = \{1, 2, 3, 5\}$
	\item $2 \ast 2 = 4 \wedge 2 \ast 3 = 6 \wedge 2 \ast 5 = 10$\\
	$H = \{1, 2, 3, 5, 4, 6, 10\}$
	\item $3 \ast 2= 6 \wedge 3 \ast 3 = 9 \wedge 3 \ast 5 = 15$\\
	$H = \{1, 2, 3, 5, 4, 6, 10, 9, 15\}$
	\item $5 \ast 2= 10 \wedge 5 \ast 3 = 15 \wedge 5 \ast 5 = 25$\\
	$H = \{1, 2, 3, 5, 4, 6, 10, 9, 15, 25\}$
\end{enumerate}
Nun stop der Algorithmus, da wir bereits die definierte Schranke erreicht haben.\\
Wenn wir die Liste sortieren dann erhalten wir folgende Folge $H = \{1, 2, 3, 4, 5, 6, 9, 10, 15, 25\}$. Diese Liste entspricht aber nicht der zu erwartenden Liste.\\
Warum ist das so ?\\
Das Problem liegt darin, dass wir zwar gültige Hammingzahlen berechnen aber diese unsortiert in der Liste vorkommen und wir daher Hammingzahlen berechnen, die in der zu erwartenden Folge nicht vorkommen dürfen.\\
Daher müssen wir die Anzahl erhöhen um sicherzustellen das in der Liste alle zu erwartenden Hammingzahlen vorhanden sind.\\
Die Zahlen die zu viel vorhanden sind können einfach am Ende des Algorithmus wieder entfernt werden wobei hier von $i = (list.size() - 1) \rightarrow i >= count$ iteriert wird und die Elemente, die zu viel sind wieder entfernt werden.\\\\
Wir könnten ein Set verwenden, was uns das Problem mit den Duplikaten ersparen würde, hätten dann aber das Problem, dass wir während der Iteration über das Set keine Elemente hinzufügen können so wie bei der Liste. Ebenso könnte es der Performance schaden das Set bei jedem add zu sortieren (TreeSet).\\
Die Verwendung von list.contains(obj) mag vielleicht nicht gerade perfekt sein jedoch sollte es kein Problem sein 10.000 Elemente der Hammingfolge unter 1 Sekunde zu ermitteln.\\\\
Die verwendete ArrayList muss auf jeden Fall mit einer Kapazität $capicity = (n+ 4)$ initialisiert werden, da wir ansonsten das Problem haben das die ArrayList ein Array.copyOf(...) durchführen würde und dynamisch um den Faktor $1.5 \ast oldCapicity$ wachsen würde, was einerseits ein mehrmaliges kopieren des Arrays und andererseits schlussendlich ein Array produzieren würde, welches weitaus größer ist als benötigt.\\
Da wir aber ohnehin wissen wie viele Elemente berechnet werden müssen kann dies über ein korrektes setzen der Kapazität vermieden werden.
\newpage
\subsection{\sourceSection}
Folgend ist der Implementierte Source und Test-Source angeführt.
\lstinputlisting{\mainPackage/hamming/Hamming.java}
\lstinputlisting{\mainTestPackage/hamming/HammingTest.java}
\subsection{\testSection}
Folgend sind die Tests der Aufgabenstellung Hammingfolge angeführt.\\
Aufgrund dessen das JUnit verwendet wurde und JUnit auch eine Report generiert wird hier auf das Einfügen der Tests verzichtet und nur der generierte JUnit Report verlinkt.\\\\
{\color{myred} ACHTUNG: Da der Report mit einen relativen Pfad eingebunden wurde darf das Dokument nicht verschoben werden ohne das gewährleistet ist, dass das Verzeichnis "\junitReportDir", welches die JUnit Reports enthält, wieder relativ gesehen an derselben Position ist}\\\\
JUnit Report öffnen (\href{\junitReportDir/index.html}{index.html})

\newpage
{\color{myred}
	\section
		{Sortieralgorithmen}
}
\subsection{\ideaSection}
Folgend sind die Lösungsideen der Sortierlagorithmen HeapSorter und QuickSorter angeführt.\\
Da beide Algorithmen denselben output liefern sollen, soll hier ein Interface spezifiziert werden welches die Funktionalität bzw. die zu implementierenden Methoden Signaturen vorgibt. Die Aufgabenstelllung verlangt zwar das Sortieren auf Integer Felder, jedoch sollen die Algorithmen so implementiert werden, dass sie auf Typen, die das Interface Compareable<E> implementieren. Daher muss das Interface folgende Signatur vorweisen.
\begin{lstlisting}
public Sorter<E extends Comparable<E>> {...}
\end{lstlisting}
Aufgrund dessen das die Sortieralgorithmen mit Code Statistics versehen werden sollen, sollen Klassen implementiert werden, die es erlauben die verlangten Statistics zu ermitteln und auch einen Report dieser zu erstellen.\\
Hierbei soll diese Code Statistics wie folgt aufgeteilt werden:
\begin{enumerate}
	\item \textbf{StatisticsProvider:} Das Interface welches die Spezifikation für den Code Statistics Provider entält.\\
	Die Implementierung soll es ermöglichen mehrere Statistic Kontexte zu verwalten.
	\item \textbf{StatisticContext:} Die Klasse, welche einen Statstic Kontext darstellt.\\
	Dieser Kontext soll es ermöglichen mehrere CodeStatistic Instanzen pro Kontext zu verwalten.
	\item \textbf{CodeStatistic:} Die Klasse, die die Code Statistic Informationen (swap, compare counts)
	\item \textbf{DefaultStatisticProviderImpl:} Die default Implementierung des Interface StatisticProvider, welches die Funktionalitäten implementiert
\end{enumerate}
\subsubsection{HeapSorter}
Folgend ist die Lösungsidee für die HeapSorter Implementierung angeführt.\\
Da hierbei 
%\includegraphics[scale=0.5]{filename goes here}

\subsection{Source Code}
\lstinputlisting{\mainPackage/hamming/Hamming.java}
\lstinputlisting{\mainPackage/sort/api/Sorter.java}
\lstinputlisting{\mainPackage/sort/api/Heap.java}
\lstinputlisting{\mainPackage/sort/heap/impl/HeapArrayListImpl.java}
\lstinputlisting{\mainPackage/sort/heap/impl/HeapSorter.java}
\lstinputlisting{\mainPackage/sort/quick/QuickSorter.java}
\subsection{\testSection}

\begin{tabular}{|r|r|l|}
\hline
Input & Output & Comment \\
\hline
a = 100 & 3 & \\
b = 200 & & \\
\hline 
\end{tabular}


\end{document}  